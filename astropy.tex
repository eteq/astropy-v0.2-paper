\documentclass[traditabstract]{aa}

\usepackage{xspace}
\usepackage{natbib}
\usepackage{url}
\bibpunct{(}{)}{;}{a}{}{,}

\newcommand{\astropy}{\texttt{astropy}\xspace}

\begin{document}

\titlerunning{Astropy}
\authorrunning{The Astropy Collaboration}

\title{Astropy: A Community Python Package for Astronomy}

% The author list is not final, and the order of authors may still change.
% Additional authors may be added based on non-commit-based contributions to
% the project.

% Please wrap text to 78 characters.

% I have indicated authors who have acknowledged authorsip by '%confirmed' next
% to their name.

\author{
The Astropy Collaboration
  \and
% Coordination committee
Erik Tollerud\inst{\ref{inst:yale}}  % confirmed
  \and
Thomas P. Robitaille\inst{\ref{inst:mpia}}  % confirmed
  \and
Perry Greenfield\inst{\ref{inst:stsci}}  % confirmed
  \and
% Developers (other than coordination committee).
Michael Droettboom\inst{\ref{inst:stsci}}  % confirmed
  \and
Tom Aldcroft\inst{\ref{inst:cfa}}  % confirmed
  \and
Erik Bray\inst{\ref{inst:stsci}}
  \and
Matt Davis\inst{\ref{inst:stsci}}  % confirmed
  \and
Adam Ginsburg\inst{\ref{inst:colorado}}  % confirmed
  \and
Adrian M. Price-Whelan\inst{\ref{inst:columbia}}  % confirmed
  \and
Wolfgang Kerzendorf\inst{\ref{inst:toronto}}
  \and
Alexander Conley\inst{\ref{inst:colorado}}
  \and
Neil Crighton\inst{\ref{inst:mpia}}  % confirmed
  \and
Kyle Barbary\inst{\ref{inst:argonne}}  % confirmed
  \and
Demitri Muna\inst{\ref{inst:nyu}}  % confirmed
  \and
Henry Ferguson\inst{\ref{inst:stsci}}
  \and
Frederic Grollier
  \and
Prasanth H. Nair\inst{\ref{inst:freelance}}  % confirmed
  \and
Hans M. G\"unther\inst{\ref{inst:cfa}}  % confirmed
  \and
Christoph Deil\inst{\ref{inst:mpik}}  % confirmed
  \and
Simon Conseil\inst{\ref{inst:oamp}}
  \and
Julien Woillez
  \and
Roban Kramer  % confirmed
  \and
James Turner\inst{\ref{inst:gemini_s}}  % confirmed
  \and
Leo Singer\inst{\ref{inst:ligo}}  % confirmed
  \and
% Other contributors, alphabetical, including coordination meeting
% participants
K. Azalee Bostroem\inst{\ref{inst:stsci}}  % confirmed
  \and
Doug Burke\inst{\ref{inst:cfa}}  % confirmed
  \and
Andy Casey\inst{\ref{inst:stromlo}}  % confirmed
  \and
Steve Crawford\inst{\ref{inst:saao}}
  \and
Nadia Dencheva\inst{\ref{inst:stsci}}  % confirmed
  \and
Justin Ely\inst{\ref{inst:stsci}}  % confirmed
  \and
Tim Jenness\inst{\ref{inst:jac}}  % confirmed
  \and
Kathleen Labrie\inst{\ref{inst:gemini_n}}  % confirmed
  \and
Pey Lian Lim\inst{\ref{inst:stsci}}  % confirmed
  \and
Francesco Pierfederici\inst{\ref{inst:stsci}}  % confirmed
  \and
Andrew Pontzen\inst{\ref{inst:oxford}}  % confirmed
  \and
Andy Ptak\inst{\ref{inst:gsfc}}  % confirmed
  \and
Brian Refsdal  % confirmed
  \and
Mathieu Servillat\inst{\ref{inst:saclay}}  % confirmed
  \and
Ole Streicher\inst{\ref{inst:leibniz}}  % confirmed
}

\institute{
  Astronomy Department, Yale University, P.O. Box 208101, New Haven, CT 06510, USA
  \label{inst:yale}
    \and
  Max Planck Institute for Astronomy, K\"onigstuhl 17, Heidelberg 69117, Germany
  \label{inst:mpia}
    \and
  Space Telescope Science Institute, 3700 San Martin Drive, Baltimore, MD 21218
  \label{inst:stsci}
    \and
  Harvard-Smithsonian Center for Astrophysics, 60 Garden Street, Cambridge, MA, 02138, USA
  \label{inst:cfa}
    \and
  Center for Astrophysics and Space Astronomy, University of Colorado, Boulder, CO 80309, USA
  \label{inst:colorado}
    \and
  Department of Astronomy, Columbia University, Pupin Hall, 550W 120th St., New York, NY 10027, USA
  \label{inst:columbia}
    \and
  Department of Astronomy and Astrophysics, University of Toronto, 50 Saint George Street, Toronto, ON M5S3H4, Canada
  \label{inst:toronto}
    \and
  Argonne National Laboratory, High Energy Physics Division, 9700 South Cass Avenue, Argonne, IL 60439, USA
  \label{inst:argonne}
    \and
  Center for Cosmology and Particle Physics, New York University, New York, NY 10003, USA
  \label{inst:nyu}
    \and
  Independent developer
  \label{inst:freelance}
    \and
  Max-Planck-Institute for Nuclear Physics, P.O. Box 103980, 69029 Heidelberg, Germany
  \label{inst:mpik}
    \and
  Laboratoire d'Astrophysique de Marseille, OAMP, Universit\'e Aix-Marseille et CNRS,
Marseille, France
  \label{inst:oamp}
    \and
  Gemini Observatory, Casilla 603, La Serena, Chile
  \label{inst:gemini_s}
    \and
  LIGO Laboratory, California Institute of Technology, 1200 E. California Blvd., Pasadena, CA, 91125, USA
  \label{inst:ligo}
    \and
  Research School of Astronomy and Astrophysics, Australian National University, Mount Stromlo Observatory
  \label{inst:stromlo}
    \and
  SAAO, P.O. Box 9, Observatory 7935, Cape Town, South Africa
  \label{inst:saao}
    \and
  Joint Astronomy Centre, 660 North A'ohoku Place, Hilo, HI 96720, USA
  \label{inst:jac}
    \and
  Gemini Observatory, 670 N. A'ohoku Place, Hilo, Hawaii 96720, USA
  \label{inst:gemini_n}
    \and
  Oxford Astrophysics, Denys Wilkinson Building, Keble Road, Oxford OX1 3RH, UK
  \label{inst:oxford}
    \and
  NASA Goddard Space Flight Center, X-ray Astrophysics Lab Code 662, Greenbelt, MD 20771, USA
  \label{inst:gsfc}
    \and
  Laboratoire AIM, CEA Saclay, Bat. 709, 91191 Gif-sur-Yvette, France
  \label{inst:saclay}
    \and
  Leibniz Institute for Astrophysics Potsdam (AIP)
  \label{inst:leibniz}
}

\abstract{
We present the first public version of the open-source and community-developed
Python package, Astropy. This package aims to provide core astronomy-related
functionality to the community, including for example support for
domain-specific file formats such as Flexible Image Transport System (FITS)
files, Virtual Observatory (VO), and common ASCII table formats, unit and
physical quantity conversions, physical constants specific to astronomy,
celestial coordinate and time transformations, world coordinate system (WCS)
support, generalized containers for representing gridded as well as tabular
data, and a framework for cosmological transformations and conversions.
Significant functionality is under active development, such as a model fitting
framework, VO client and server tools, and aperture and point spread function
(PSF) photometry tools. Participation in development is open to anyone
interested in joining the project.

}

\maketitle

\tableofcontents


\section{Introduction}

% Authors: Tom R., Erik T., Perry G.

The Python programming language\footnote{\url{http://www.astropy.org}} has been
one of the fastest-growing programming languages in the astronomy community in
the last decade. While there have been a number of efforts to develop Python
packages for astronomy-specific functionality, these efforts have been
fragmented, and several dozens of packages have been developed across the
community with little or no coordination, leading to duplication and a lack of
homogeneity across packages. This in turn has made it difficult for users to
get set up with all the required packages needed in an Astronomer's toolkit.
Since a number of these packages depend on individual or small groups of
developers, packages are sometimes no longer maintained, or simply become
unavailable, which is detrimental to long-term research and research
reproducibility.

The Astropy project was started\footnote{Following discussions on
the \texttt{astropy} mailing list at
\url{http://mail.scipy.org/mailman/listinfo/astropy}} in 2011 out of a desire
to bring together developers across the field of astronomy in order to
coordinate efforts to develop a common Python library. The aim of this library
was to cover much of the astronomy-specific functionality needed by
researchers, complementing more general standard scientific packages such as
NumPy \citep{oliphant2006guide,van2011numpy} and SciPy \citep{jones2001scipy},
which are invaluable for numerical array-based calculations, and more general
scientific algorithms (e.g. interpolation, integration, clustering, etc.)
respectively. To date, over 130 people are signed up to the
\textit{development} mailing list for the Astropy project\footnote{
\url{https://groups.google.com/forum/?fromgroups\#!forum/astropy-dev}}.

Most efforts in the Astropy project to date have gone towards developing the
core \astropy package. However, we note the scope of the Astropy project is
not simply to create a core package, but more generally to bring together
authors of existing packages to work together and agree on including a common
set of functionality in the core package (and in some cases deprecating their
packages if all functionality ends up in \astropy), since the aim is
ultimately to simplify the landscape of packages available to users. In
addition, the Astropy project includes more specialized Python packages (which
we call \textit{affiliated} packages) that are not included in the core
package for various reasons: for some the functionality is in early stages of
development and is not robust; or the license is not compatible with Astropy;
the package includes large files; or the functionality is mature, but too
specific to be included in a core package.

In this paper, we present the first public release (v0.2) of the \astropy
package. We provide an overview of the current capabilities
(\S\ref{sec:capabilities}), our development workflow (\S\ref{sec:workflow}),
and planned functionality (\S\ref{sec:future}).


\section{Capabilities}

\label{sec:capabilities}


\subsection{Units, Quantities, and Physical Constants}

% Authors: Perry, Mike, Adrian, Tom R.

The \texttt{astropy.units} package provides support for physical
units.  It is based on the code in the \texttt{pynbody} package
[reference?]  written by Andrew Pontzen, but has since been enhanced
in behavior and implementation.

Converting between units is simple:
\begin{verbatim}
>>> from astropy import units as u
>>> # Convert from parsec to meter
>>> u.pc.to(u.m)
3.0856776e+16
\end{verbatim}
The user can also define their own units, either as standalone base
units or by composing other units together.  This is done using simple
mathematical operators.  For example:
\begin{verbatim}
>>> # Define some custom units
>>> cms = u.cm / u.s
>>> mph = u.mile / u.hour
>>> cms.to(mph, 1)
0.02236936292054402
\end{verbatim}

Astropy knows about certain physical ``concepts'' and is able to
deduce the purpose of a unit, even if it is user-defined.  Using the
example of mile-per-hour (\texttt{mph}) from above:
\begin{verbatim}
>>> mph = u.mile / u.hour
>>> mph.physical_type
u'speed'
\end{verbatim}

\texttt{astropy.units} includes unit definitions in both the
International System of Units (SI) and the Centimeter-Gram-Second
(CGS) systems, as well as a number of astronomy- and
astrophysics-specific units.  Converting between systems is possible:
\begin{verbatim}
>>> u.Pa.to_system(u.cgs)
[Unit("1.000000e+01 Ba")]
\end{verbatim}

It's also possible to decompose units into their base units, and then
pattern match those parts against known units.
\begin{verbatim}
>>> u.Hz.decompose()
Unit("1 / (s)")
>>> (1.0 / u.s).compose()
>>> (u.s ** -1).compose()
[Unit("Hz"), ...]
\end{verbatim}
[TODO: won't (1.0 / u.s).compose() fail because 1/u.s is a Quantity? -
  apw]

Included is the concept of ``equivalencies'' in units, where there
exists an equation that provides a relationship between two different
physical quantities such that providing either one uniquely defines
the other.  A standard astronomical example is the relationships
between the frequency, wavelength and energy of a photon.  Specify
one, and you specify all the others. It is common practice to treat
the units as equivalent even though they aren't strictly comparable.
This unit package supports defining such relationships, and it is one
of the areas that distinguish itself from most other units handling
software.  For example, wavelength and frequency are not normally
convertible:
\begin{verbatim}
>>> u.nm.to(u.Hz, [1000, 2000])
UnitsException: 'nm' (length) and 'Hz'
(frequency) are not convertible
\end{verbatim}
However, by passing an equivalency list (\texttt{u.spectral()}), it
does:
\begin{verbatim}
>>> u.nm.to(u.Hz, [1000, 2000],
            equivalencies=u.spectral())
array([  2.99792458e+14,   1.49896229e+14])
\end{verbatim}
Equivalencies are also included for flux densities, and end users can
easily implement their own equivalencies.

%TODO: add a description of the original motivation for equivalencies:
%flux density conversions.  Also possibly a description of the on-list
%discussion of the complexities in this topic

It's well known that there are multiple string representations for
units used in the astronomy community.  The FITS Standard
\cite{fits2008} defines a unit standard, as well as both the Centre de
Donn\'ees astronomiques de Strasbourg (CDS) \citep{ochsenbein2000cds}
and NASA/Goddard's Office of Guest Investigator Programs (OGIP)
\citep{george1995ogip}.  In additional, the International Virtual
Observatory Alliance (IVOA) has a forthcoming VOUnit standard
\citep{derriere2012vounit} in an attempt to resolve some of these
differences.  Rather than choose one of these, \texttt{astropy.units}
supports all of these standards\footnote{OGIP support is forthcoming
  at the time of this writing.}, and allows the user to select the
appropriate one when reading and writing unit string definitions to
and from external file formats.

Also included in the \texttt{astropy.units} package is the
\texttt{Quantity} object, which represents a numerical value with an
associated unit.  These objects support arithmetic with other numbers
and \texttt{Quantity} objects and preserve their units:
\begin{verbatim}
>>> x = 15.1 * u.m / (32.0 * u.s)
>>> x
<Quantity 0.471875 m / (s)>
>>> x.unit
Unit("m / (s)")
>>> x.value
0.471875
\end{verbatim}

Using the \texttt{.to()} method, \texttt{Quantity} objects can be
converted to different units. The units must either be dimensionally
equivalent, or you must pass equivalencies through the
\texttt{equivalencies} argument (see discussion of ``equivalencies''
above):
\begin{verbatim}
>>> (1.15E13*u.km).to(u.pc)
<Quantity 0.372689618289 pc>
>>> (130.*u.GeV).to(u.Angstrom, equivalencies=u.spectral())
<Quantity 9.53724560923e-08 Angstrom>
\end{verbatim}

\texttt{Quantity} objects support arithmetic. When adding or
subtracting, if the units are equivalent but not equal
(e.g. centimeter and meter), the resulting object has units of the
object on the left:
\begin{verbatim}
>>> 110. * u.cm + 1.5 * u.m
<Quantity 260.0 cm>
>>> 1.5 * u.m  + 110. * u.cm
<Quantity 2.6 m>
\end{verbatim}

For multiplication and division, the resulting object will retain all
units used in the expression. The final object can then be converted
to a specified set of units or ``decomposed'', effectively canceling
and combining any equivalent units and returning a \texttt{Quantity}
object in some set of base units (default is SI):

\begin{verbatim}
>>> x = 1.4E11*u.km / (0.7*u.Myr) / (4.1E11*u.s)
>>> x
<Quantity 0.487804878049 km / (Myr s)>
>>> x.decompose()
<Quantity 1.54579339587e-11 m / (s2)>
>>> x.decompose(bases=u.cgs.bases)
<Quantity 1.54579339587e-09 cm / (s2)>
>>> x.decompose(bases=[u.kpc, u.Myr])
<Quantity 0.000498873327903 kpc / (Myr2)>
\end{verbatim}

\texttt{Quantity} objects can also be created with \texttt{numpy}
arrays:
\begin{verbatim}
>>> x = np.array([1,2,3])*u.km
>>> x
<Quantity [1 2 3] km>
>>> x.unit
Unit("km")
>>> x.value
array([1, 2, 3])
\end{verbatim}

[TODO: Do we want to mention that they currently don't support
  arbitrary decimal powers?]

These \texttt{Quantity} objects are used to define a number of useful
astronomical constants included with \texttt{astropy}, each with an
associated unit (where applicable) and additional metadata describing
their provenance and uncertainties.
\begin{verbatim}
>>> from astropy.constants import si
>>> print si.c
  Name   = Speed of light in vacuum
  Value  = 299792458.0
  Error  = 0.0
  Units = m / (s)
  Reference = CODATA 2010
>>> print si.c.to('km/s')
299792.458 km / (s)
\end{verbatim}

The combination of all of the above ends up being rather powerful:
\begin{verbatim}
>>> from astropy.constants import G, M_sun
>>> F = G * (3. * M_sun) *
        (2. * u.kg) / (1.5 * u.au)**2
>>> F.to(u.N)
<Quantity 0.01581795428812989 N>
\end{verbatim}

\subsection{Time}

% Authors: Tom A.


\subsection{Celestial Coordinates}

% Authors: Erik T., Adrian, Demitri

%% 1. Introduction/Design goals [APW & ET]
%%     a. need a class-based representation
%%     b. should be totally customizable
%%     c. fast enough for “big data” (not there yet)

An essential element of any astronomy workflow 
is the manipulation, parsing, and conversion of astronomical coordinates.
This functionality is provided by the \texttt{astropy.coordinates} sub-package.
The main element of the design philosophy is that the code should
be easily readable, even by those new to Python. Typical operations should
appear in code similar to
how they would appear if expressed in spoken or written language.
The package is designed to present a natural Python
interface for representing coordinates in computations, simplify
input/output formatting, and allow straightforward transformation
between coordinate systems. It is also supports implementation of new or custom
coordinate systems that work consistently with the built-in systems.
A future design goal is to also seamlessly
support arbitrarily large data sets.

One aim of the package is to provide a common application programming interface (API)
for Python astronomy packages that use coordinates, as well as
relieve users from having to (re)implement what are extremely common utilities.
To achieve this, it leverages important lessons learned from existing
Python coordinates packages such as \texttt{kapteyn}, \texttt{pyast},
\texttt{pyephem} \citep{pyephem}, and \texttt{astropysics}
\citep{astropysics} that this package aims to supplant.

%% 2. Coordinate systems overview [ET & APW]
The \texttt{astropy.coordinates} sub-package
is built around a set of classes that represent coordinate systems.
The abstract class \texttt{SphericalCoordinatesBase} is the superclass
for all of these systems and contains much of the functionality. The
individual systems provide customized initializers and appropriate
formatting and representation defaults. For some classes, they also
contain added functionality specific to a subset of systems, such as
code to precess a coordinate to a new equinox. The implemented
systems include a variety of equatorial coordinate systems (ICRS, FK4,
and FK5), galactic coordinates, and horizontal (alt/az) coordinates.
Future versions of Astropy will include additional
common systems, including ecliptic systems, supergalactic coordinates,
and all necessary intermediate coordinate systems for the IAU
2000/2006 equatorial-to-horizontal mapping \citep[e.g.,][]{soffel03,
  usnocircular179}.


%% 3. Input Parsing / Creating coordinate objects [APW]
%%     a. can all be customized
%%     b. Angle
%% 4. Representations/string outputs [APW]

%% 5. Transformation infrastructure [ET]
%%     a. can all be customized
A crucial feature for an astronomical coordinate framework is a methodology for
transforming between coordinate systems. The \texttt{astropy.coordinates}
package implements this with a guiding philosophy that it
should be easy to add new systems with minimal bookkeeping by the
user. In fact, it is possible for a new contributor or user to add a new
coordinate system with only a class definition and two transformation
functions. Coordinate systems added in this manner are ``first-class citizens'' of the
package, meaning that they have all the capabilities of the systems that are included in the
package.

This flexibility is achieved in \texttt{astropy.coordinates} through the use
of a transformation graph.
All coordinate systems are represented as classes; internally, the
transformation infrastructure keeps track of a network of coordinate systems
and the transformations between them.  When a coordinate
object is to be transformed from one system into another, the package determines the shortest path on
the transformation graph to the new system and applies the necessary
sequence of transformations. Thus, implementing a new coordinate system
only requires implementing one
pair of transformations to and from a system that is already connected to the
transformation graph. Once this pair is specified,
\texttt{astropy.coordinates} can transform from that coordinate
system to any other in the graph. This greatly simplifies
implementation and mirrors the way most coordinate systems are
defined. For example, galactic coordinates are defined relative to FK4
coordinates rather than with respect to a set of other common coordinate
systems \citep{galcoords, reid04}.

The transformation system also provides a variety of helpers to make writing
new transformations easier.  In particular, it allows transformations to be
defined either as standard Python functions (for full flexibility) or as
matrices converting the Cartesian coordinates of one system into those of the
other. These matrices can be dynamically generated for each object or be a
single matrix for all transformations between two systems. This allows
designers of transformation functions to drastically improve performance for
systems with simple linear relations while still having the full
customization necessary for more complicated transformations (e.g.,
transformations fully consistent with general relativity).

Transformations are provided between all coordinate systems built into
version 0.2 of \texttt{astropy.coordinates} with the exception of conversions from
celestial to horizontal coordinates. Transforming to horizontal
coordinates is an important feature for any astronomy package,
however, it requires an observer location and additional information [what additional information?].
Implementing this transformations has been delayed to a
future release. The intent for the next major release is to implement the
transformation architecture endorsed by the IAU 2000/2006 resolutions
\citep[see e.g.,][]{soffel03, usnocircular179}. This will enable practical
calculations (such as the visibility of targets over the year) while maintaining
compliance with modern astronomy standards.


%% 6. Third dimension/distance added bits (incl. separations) [ET]
A final important piece of \texttt{astropy.coordinates} is support for
line of sight distances. While the term ``celestial coordinates'' can be
taken to refer to only on-sky angles, in \texttt{astropy.coordinates} a
coordinate object is conceptually treated as a point in three dimensional space.
Users have the option of specifying a line of sight distance to the
object from the origin of the coordinate system (typically the origin is the
Earth or solar system barycenter). These distances can be given in physical
units or as redshifts. The \texttt{astropy.coordinates} package will in the
latter case transparently make use of the cosmological calculations in \texttt{astropy.cosmology} for
conversion to physical distances.
The transformation system fully supports distances, preserving
the orientations of coordinates both for transformations that are purely
rotations and for those that involve translations.  Finally, when
line of sight distances are provided, the \texttt{separation3d} method of the
coordinate objects provides direct and convenient calculations of
three dimensional distances.

%% 3. Input Parsing / Creating coordinate objects [APW]
%%     a. can all be customized
%%     b. Angle

Creating coordinate objects is done by directly initializing a
particular coordinate system using standard Python class
instantiation. Astronomical coordinates may be expressed in a myriad
of ways: the classes support string, numeric, and tuple value
specification through a sophisticated input parser.
A coordinate angle is defined as a numeric value and a unit.
A design goal of the input parser is to be able to determine the
angle value and unit from the input alone if a person can
unambiguously determine them.
For example, an astronomer seeing the input string ``12h53m11.5123s"
would understand the units to be in hours, minutes, and seconds, so this
value is alone sufficient to pass to the angle initializer. The value "5.43" is
unambiguous by itself, so in this case the additional \textt{unit} argument is required to
fully define the angle, e.g.

\begin{verbatim}
>>> from astropy.coordinates import Angle
>>> import astropy.units as u
>>> a = Angle(12, unit=u.degree)
\end{verbatim}

The individual coordinates are stored internally as \texttt{Angle}
objects, a class defined in \texttt{astropy.coordinates} for handling
angular values. \texttt{Angle} objects can be instantiated and used on their
own and provide a variety of functionality for parsing and representing
angular values. Once created, the object can provide conversions to angular units
such radians, hours, degrees, or sexagesimal tuples through attributes:

\begin{verbatim}
>>> from astropy.coordinates import Angle
>>> a = Angle(118.439234, unit=u.degree)
>>> a.radians
2.067154596840014
>>> a.hms
(7.0, 53, 45.41616000000232)
\end{verbatim}

The \texttt{format()} method provides a variety of options for
controlling string representations of the value. The method supports
most commonly used output formats by specifying separating characters
(for sexagesimal representation), the output unit, and precision of
the value.

[give examples - this is a cool feature -dm]

Bounds can also be set on angles so that numerical
values may be easily transformed to a given range, e.g. from (-180,180) to (0,360).

[It's not really clear what you are trying to demonstrate - can you give an example? -dm]

\subsection{Tables and Gridded data}

% Authors: Tom A., Tom R., Wolfgang K., Erik T.

\label{sec:table}

The \texttt{astropy.table} and \texttt{astropy.nddata} sub-packages contain
classes (\texttt{Table} and \texttt{NDData}) that allow users to represent
astronomical data in the form of tables or n-dimensional gridded datasets,
including meta-data (for example units).

The \texttt{Table} class provides a high-level wrapper to Numpy structured
arrays, which are essentially arrays that have fields (or columns) with
heterogeneous data types, and any number of rows. Numpy structured arrays are∏
however difficult to manipulate or modify, so the \texttt{Table} class makes
it easy for users to create a table from columns, add/remove columns or rows,
and mask values from the table. In addition, tables can be easily
read/written from/to common file formats using the \texttt{Table.read} and
\texttt{Table.write} methods. In addition to providing easy manipulation and
input/output of table objects, the \texttt{Table} class allows units to be
specified for each column using the \texttt{astropy.units} framework, and
also allows the \texttt{Table} object to contain arbitrary meta-data (stored
in \texttt{Table.meta}).


The \texttt{NDData} class ...

\subsection{File Formats}


\subsubsection{FITS}

% Authors: Erik B.


\subsubsection{ASCII table formats}

% Authors: Tom A.


\subsubsection{Virtual Observatory tables}

% Authors: Mike D.
\texttt{astropy.io.votable} (formerly the standalone project
\texttt{vo.table}) provides full support for reading and writing
VOTable format files versions 1.1 and 1.2
\citep{ochsenbein2004votable,ochsenbein2009votable}.  It efficently
stores the tables in memory as Numpy structured arrays.  The file is
read using streaming to avoid reading in the entire file at once and
greatly reducing the memory footprint.

It is possible to convert any one of the tables in a VOTable file to
an \texttt{astropy.table.Table} object (\S\ref{sec:table}), where it
can be edited and then written back to a VOTable file without any loss
of data.

The VOTable standard is not strictly adhered to by all VOTable file
writers in the wild.  Therefore, \texttt{astropy.io.votable} provides
a number of tricks and workarounds to support as many VOTable sources
as possible, whenever the result would not be ambiguous.  A validation
tool (\texttt{volint}) is also provided that outputs recommendations
to improve the standard compliance of a given file, as well as
validate it against the official VOTable schema.

Support for VOTable 1.3 is planned for the future.

\subsection{World Coordinate Systems}

% Authors: Mike D.

\texttt{astropy.wcs} contains utilities for managing World Coordinate
System (WCS) transformations in FITS files.  These transformations map
the pixel locations in an image to their real-world units, such as
their position on the celestial sphere.  This library is specific to
WCS as it relates to FITS as described in the FITS WCS papers
\citep{greisen2002wcs,calabretta2002wcs,greisen2006wcs} and is
distinct from a planned Astropy package that will handle WCS
transformations in general, regardless of their representation.

\texttt{astropy.wcs} is a wrapper around Mark Calabretta's
\texttt{wcslib} \citep{calabretta2013wcslib}.  Since all of the FITS
header parsing is done using \texttt{wcslib}, it is assured the same
behavior as the many other tools that use \texttt{wcslib}.  On top of
the basic FITS WCS support, it adds support for the Simple Imaging
Polynomial (SIP) convention and table lookup distortions as defined in
the draft WCS ``Paper IV'' \citep{calabretta2004wcs}.  Each of these
transformations can be used independently or together in a fixed
pipeline.

\texttt{astropy.wcs} also serves as a useful FITS WCS validation tool,
as it is able to report on many common mistakes or deviations from the
standard in a given FITS file.

\subsection{Cosmology}

% Authors: Neil Crighton, Alex Conley

The \texttt{astropy.cosmology} sub-package contains classes for
representing widely used cosmologies, and functions for calculating
quantities that depend on a cosmological model. It also contains a
framework for working with less frequently employed cosmologies that
may be not be flat, or have a time-varying pressure to density ratio,
$w$, for dark energy. The quantities that can be calculated are
generally taken from those described by \citet{Hogg99}. Some examples
are the angular diameter distance, comoving distance, critical
density, distance modulus, lookback time, luminosity distance, and
Hubble parameter as a function of redshift.

The fundamental model for this sub-package is that any given cosmology
is represented by a class. An instance of this class has attributes
giving all the parameters required to uniquely specify the cosmology,
such as the Hubble parameter, CMB temperature and the baryonic, cold
dark matter, and dark energy densities at $z=0$. One can then use
methods of this class to perform calculations using these parameters.

For example, the \texttt{FlatLambdaCDM} class represents a flat
cosmology with a cosmological constant. To create an object
representing a flat cosmology \texttt{cosmo} with a Hubble parameter
$H_{z=0} = 70$~km\,s$^{-1}$\,Mpc and $\Omega_{M,z=0} = 0.3$, one would
use:

\begin{verbatim}
>>> from astropy.cosmology import FlatLambdaCDM
>>> cosmo = FlatLambdaCDM(H0=70, Om0=0.3)
\end{verbatim}

\noindent Then the comoving volume (for example) can be calculated at
redshift $6.5$ using the \texttt{comoving\_volume} method:

\begin{verbatim}
>>> cosmo.comoving_volume(6.5)
1074707289417.6837
\end{verbatim}

\noindent Further calculations can be performed using the many methods
of \texttt{cosmo}, such as \texttt{cosmo.lookback\_time} and
\texttt{cosmo.comoving\_distance}.  For users who are more comfortable
using a procedural coding style, these methods are also available as
functions that take a cosmology class instance as a keyword argument.

The sub-package provides several pre-defined cosmology instances
corresponding to commonly used cosmological parameter sets. Currently
parameters from the WMAP 5-year \citep{Komatsu09}, 7-year
\citep{Komatsu11} and 9-year results \citep{Hinshaw13} are included
(\texttt{WMAP5}, \texttt{WMAP7} and \texttt{WMAP9}). There are several
classes corresponding to non-flat cosmologies, and the most common
dark energy models are supported: a cosmological constant, constant
$w$, and $w(a) = w_0 + w_a (1-a)$ (e.g. \citealt{Linder03}, here $a$
is the scale factor). Any other arbitrary cosmology can be represented
by sub-classing one of the basic cosmology classes.

All of the code in the sub-package is tested against the web-based
cosmology calculator by \citet{Wright06} and two other widely-used
calculators\footnote{\url{http://www.kempner.net/cosmic.php},\\ \url{http://www.icosmos.co.uk/index.html}}.
In cases when these calculators are not precise enough to enable a
meaningful comparison, the code is tested against calculations
performed with \textsc{Mathematica}.

\section{Development workflow}

\label{sec:workflow}

% Describe tools used in the development process, and how development is managed (not specifically how we use git, but higher-level.

% Authors: Tom R., Erik T., Perry G.


\section{Planned functionality}

\label{sec:future}

% Authors: Tom R., Erik T., Perry G.


\section{Summary}

\label{sec:summary}

% Authors: Tom R., Erik T., Perry G.

\bibliographystyle{apj_custom}
\bibliography{apj-jour,references}

\end{document}
